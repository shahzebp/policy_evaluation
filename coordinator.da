import sys

import queue

import logging
import logging.handlers
import logging.config

from time import sleep
from threading import Thread
from collections import deque
from datetime import datetime
import time

from worker import Worker
from common import Request, Response

class Coordinator(process):

    def setup(coordinators:list, database, config):
        self.logger = logging.getLogger('sLogger')

        self.status = False
        
        self.sub_main_cache = {}
        self.sub_tent_cache = {}

        self.res_main_cache = {}
        self.sequence       = 0

        self.response_queue = queue.PriorityQueue(maxsize=0)       

        # thread safe implementation 
        self.pending_queue  = deque()
        # Each coordinator intantiates its own workers
        # It is one as of now
        num_worker = int(config.get("setup", "num_worker_per_coord"))

        workers_set     = new(Worker, num = num_worker)
        self.workers    = list(workers_set)
        setup(self.workers, (coordinators, database, config))
        start(workers)


    def run():
        await(status == True)

    def attributes_in_sync(map1, map2): 
        pass
        for key in map1:
            timestamp1 = map1[key][1]

            if key in map2:
                timepstamp2 = map2[key][1]

                # TODO shoule there be other comparison?
                if(timestamp1 != timepstamp2):
                    return False

        return True

    def attributes_clash(map1, map2):
        for key in map1:
            if key in map2:
                return False

        return True

    def check_conflict(latest_tentative_map, sent_tent_map, changelist_map): 

        if not sent_tent_map:
            return attributes_clash(changelist_map, latest_tentative_map)
        else:
            return (attributes_in_sync(sent_tent_map, latest_tentative_map)
                and attributes_clash(changelist_map, latest_tentative_map))

    def entrypoint(request):
        logger.debug("Subject coord request received: %s", str(request))

        # TODO REMOVE THIS fake test
        sub_main_cache[request.subject_id] = {"history":("70", time.time())}
        if request.subject_id in sub_main_cache:
            request.sub_tent_updates = sub_main_cache[request.subject_id]

        
        request.timestamp   = time.time()

        rid = request.resource_id % len(coordinators)

        pending_queue.append(request)

        send(('FROM_SUBJECT_COORD', request), to=(coordinators[rid]))

    def receive(msg=('FROM_CLIENT', request), from_=p):
        request.owner       = p
        entrypoint(request)


    def receive(msg=('FROM_SUBJECT_COORD', request), from_=p):

        logger.debug("Resource coord request received: %s ", str(request))

        # TODO REMOVE THIS 
        res_main_cache[request.resource_id] = {"id":("bank A", time.time())}
        if request.resource_id in res_main_cache:
            request.res_tent_updates = res_main_cache[request.resource_id]

        wid = request.resource_id % len(workers)

        send(('FROM_RECEIVE_COORD', request), to = (workers[wid]))

    def extract_next_response():

        if (response_queue.empty() == False):

            response = response_queue.get()[1]

            if (pending_queue[0].timestamp < response.request.timestamp):
                response_queue.put(response.request.timestamp, response)
            else:
                process_response(response)

    def process_response(response):
        logger.debug("Processing response: %s ", str(response))

        # No need to check in tentative cache. By this time, the tentative
        # updates for earlier requests has either been resolved or reverted

        # Check if evalution result is true, if false, return directly to client
        # as no updates should be processed and no conflicts should be checked
        if response.result == False:
            send(('OUTCOME', response), to = (response.request.owner))
            pending_queue.popleft()

        logger.debug("Checking subject conflicts: %s ", str(response))
        retval = True
        if response.request.subject_id in sub_main_cache:
            retval = check_conflict(sub_main_cache[response.request.subject_id],
                                    response.request.sub_tent_updates,
                                    response.sub_changelist)

        if (retval == True):

            # Execute tentative updates            
            current_tent_map = {}
            if response.request.subject_id in sub_tent_cache:
               current_tent_map =  sub_tent_cache[response.request.subject_id]

            for k,v in response.sub_to_update:
                current_tent_map[k] = (v, time.time())

            sub_tent_cache[response.request.subject_id] = current_tent_map

            # Check for resource conclicts
            rid = response.request.resource_id % len(coordinators)
            send(('FROM_SUBJECT_COORD_RESPONSE', response), to=(coordinators[rid]))
            
        else:
            # Restart
            logger.error("Subject conflict detected: %s ", str(response))
            logger.debug("Restarting: %s ", str(response.request))
            
            pending_queue.popleft()
            entrypoint(response.request)

    def receive(msg=('FROM_WORKER', response), from_=p):
        logger.debug("From worker: %s ", str(response))
        
        retval = True

        if (pending_queue[0].timestamp < response.request.timestamp):
            response_queue.put((response.request.timestamp, response))
        else:
            process_response(response)
 
    def receive(msg=('FROM_SUBJECT_COORD_RESPONSE', response), from_ = p):
        logger.debug("Checking resource conflict: %s ", str(response))

        retval = True
        if response.request.resource_id in res_main_cache:
            retval = check_conflict(res_main_cache[response.request.resource_id],
                                    response.request.res_tent_updates, response.res_changelist)

        if (retval == True):

            # Execute tentative updates            
            current_tent_map = {}
            if response.request.resource_id in res_main_cache:
               current_tent_map =  res_main_cache[response.request.resource_id]

            for k,v in response.res_to_update:
                current_tent_map[k] = (v, time.time())

            res_main_cache[response.request.subject_id] = current_tent_map

        # Need to send result to subject in either conflict or no conflict case
        rid = response.request.subject_id % len(coordinators)
        send(('FROM_RESOURCE_COORD_RESPONSE', response, retval), to=(coordinators[rid]))

    def receive(msg=('FROM_RESOURCE_COORD_RESPONSE', response, retval), from_ = p):
        if (True == retval):
            # No conflict, propapage the tentative subject updates to main
            logger.debug("Evaluation complete: %s", str(response))

            send(('OUTCOME', response), to = (response.request.owner))
            pending_queue.popleft()
            # Process next response that was queued
            extract_next_response()
        else:
            logger.error("Resource conflict detected: %s ", str(response))
            logger.debug("Restarting: %s ", str(response.request))
            pending_queue.popleft()
            entrypoint(response.request)