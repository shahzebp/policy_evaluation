import sys
from time import sleep
from collections import deque
from datetime import datetime

from worker import Worker
from common import Request, Response

class Coordinator(process):
 
    def setup(coordinators:list, database, config):
        self.status = False
        
        self.sub_main_cache = {}
        self.sub_tent_cache = {}

        self.res_main_cache = {}
        self.sequence       = 0
        
        self.pending_queue  = deque()
        # Each coordinator intantiates its own workers
        # It is one as of now
        num_worker = int(config.get("setup", "num_worker_per_coord"))

        workers_set     = new(Worker, num = num_worker)
        self.workers    = list(workers_set)
        setup(self.workers, (coordinators, database, config))
        start(workers)


    def run():
        output("Run run run")
        await(status == True)

    def attributes_in_sync(map1, map2): 
        pass
        for key in map1:
            timestamp1 = map1[key][1]

            if key in map2:
                timepstamp2 = map2[key][1]

                # TODO shoule there be other comparison?
                if(timestamp1 != timepstamp2):
                    return False

        return True

    def attributes_clash(map1, map2):
        for key in map1:
            if key in map2:
                return False

        return True

    def check_conflict(latest_tentative_map, sent_tent_map, changelist_map): 

        if not sent_tent_map:
            return attributes_clash(changelist_map, latest_tentative_map)
        else:
            return (attributes_in_sync(sent_tent_map, latest_tentative_map)
                and attributes_clash(changelist_map, latest_tentative_map))

    def entrypoint(request):
        output("Subject coord request ", request.subject_id)

        # TODO REMOVE THIS fake test
        sub_main_cache[request.subject_id] = {"history":("70", datetime.now())}
        if request.subject_id in sub_main_cache:
            request.sub_tent_updates = sub_main_cache[request.subject_id]

        
        request.timestamp   = datetime.now()

        rid = request.resource_id % len(coordinators)

        pending_queue.append(request)

        send(('FROM_SUBJECT_COORD', request), to=(coordinators[rid]))


    def receive(msg=('FROM_CLIENT', request), from_=p):
        request.owner       = p
        entrypoint(request)


    def receive(msg=('FROM_SUBJECT_COORD', request), from_=p):

        output("Resource coord request", request.resource_id)

        # TODO REMOVE THIS 
        res_main_cache[request.resource_id] = {"id":("bank A", datetime.now())}
        if request.resource_id in res_main_cache:
            request.res_tent_updates = res_main_cache[request.resource_id]

        wid = request.resource_id % len(workers)

        send(('FROM_RECEIVE_COORD', request), to = (workers[wid]))

    def receive(msg=('FROM_WORKER', response), from_=p):
        output("From worker : ", response.request.subject_id)
        
        retval = True

        # TODO use id here
        print("Pending ", pending_queue[0].timestamp)
        print("current ", response.request.timestamp)

        #await(pending_queue[0].timestamp >= response.request.timestamp)

        # No need to check in tentative cache. By this time, the tentative
        # updates for earlier requests has either been resolved or reverted

        # Check if evalution result is true, if false, return directly to client
        # as no updates should be processed and no conflicts should be checked
        if response.result == False:
            send(('OUTCOME', response), to = (response.request.owner))
            pending_queue.popleft()


        retval = True
        if response.request.subject_id in sub_main_cache:
            retval = check_conflict(sub_main_cache[response.request.subject_id],
                                    response.request.sub_tent_updates,
                                    response.sub_changelist)

        if (retval == True):

            # Execute tentative updates            
            current_tent_map = {}
            if response.request.subject_id in sub_tent_cache:
               current_tent_map =  sub_tent_cache[response.request.subject_id]

            for k,v in response.sub_to_update:
                current_tent_map[k] = (v, datetime.now())

            sub_tent_cache[response.request.subject_id] = current_tent_map

            # Check for resource conclicts
            rid = response.request.resource_id % len(coordinators)
            send(('FROM_SUBJECT_COORD_RESPONSE', response), to=(coordinators[rid]))
        else:
            # Restart
            pending_queue.popleft()
            entrypoint(response.request)

    def receive(msg=('FROM_SUBJECT_COORD_RESPONSE', response), from_ = p):
        output("resolving resource conflict", response.request.resource_id)

        retval = True
        if response.request.resource_id in res_main_cache:
            retval = check_conflict(res_main_cache[response.request.resource_id],
                                    response.request.res_tent_updates, response.res_changelist)

        if (retval == True):

            # Execute tentative updates            
            current_tent_map = {}
            if response.request.resource_id in res_main_cache:
               current_tent_map =  res_main_cache[response.request.resource_id]

            for k,v in response.res_to_update:
                current_tent_map[k] = (v, datetime.now())

            res_main_cache[response.request.subject_id] = current_tent_map

        # Need to send result to subject in either conflict or no conflict case
        rid = response.request.subject_id % len(coordinators)
        send(('FROM_RESOURCE_COORD_RESPONSE', response, retval), to=(coordinators[rid]))

    def receive(msg=('FROM_RESOURCE_COORD_RESPONSE', response, retval), from_ = p):
        if (True == retval):
            # No conflict, propapage the tentative subject updates to main
            output("succesfull evaluation ", response.request.action)

            send(('OUTCOME', response), to = (response.request.owner))
            pending_queue.popleft()
        else:
            pending_queue.popleft()
            entrypoint(response.request)